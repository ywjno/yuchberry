= 加密密码 =
<wiki:toc max_depth="3" />

   自架服务器的时候，填写config.xml，设置邮件帐户密码的时候，都会填写一个明文密码，这个密码保存在服务器上，如果服务器被攻破，那么损失会很严重。

   很多朋友提起过这个问题，建议用简单的方法加密一下，一开始，不想解决这个问题，因为牵涉到使用复杂性，就暂时搁浅了。

   这里不得不提到一位朋友，他赞助了语盒一个3位数的金额，唯一的要求就是解决这个明文密码的问题，我汗颜，不得不感到这个问题紧迫性。一不做二不休，就做一个做一个相对安全的方法吧。

   下面说一说原理。


== 加密算法 ==

   加密算法用的是DES（不懂的百度谷歌一下），算法很数学，不多说了（我也不懂）。其中用到一个算子（Key）——作为加密解密的钥匙，如果一个人获得了密文还有这个密文算子，才能用算法解密出明文。

   在安装JRE之后，运行服务器文件夹中的 <b>cryptPasswordTool.bat</b> （或者命令行工具 <b>cryptPasswordTool_console.bat</b> 可以在 GNU/Linux 纯命令行的界面中运行），就会出现下面的界面（也可以访问[http://api.yuchs.com/passgen.html 网页版本]，无需安装jre）：

   [http://i.imgur.com/ZaeDh.jpg]

   密码算子在使用工具的时候，填写的是一个明文，但事实上加密解密的时候，算子并不是这个明文，而是使用MD5算法处理过的：
{{{
        KEY = MD5(key)

        PASSWORD = DES(KEY,password)
}}}
   上面图中工具显示的公式：
{{{
        KEY = MD5("111")

        "cf490ecbdc4719bbef8857158d44258d" = DES(KEY,"password")
}}}

== 使用加密密码 ==

  * 服务器准备
   填写config.xml的时候，以前填写 EmailAccount 标签的时候，字段 password的时候是明文密码，例如：
{{{
       <EmailAccount 
                account="yuchberry@gmail.com" 
                password="password" 
                ...
       />
}}}
   现在加入一个字段 <font color="red">cryptPassword</font> ，用于填写工具算出来的加密密码，而且要把原来的<font color="red">password留空</font>，如果不留空，程序会优先选择明文密码登录。从上面的例子来看，就是:
{{{
       <EmailAccount 
                account="yuchberry@gmail.com" 
                password="" 
                cryptPassword="cf490ecbdc4719bbef8857158d44258d" 
                ...
       />
}}}
   当然，那个加密算子 MD5("111")，config.xml是不知道，在运行的服务器的时候，会出现一句话：<br />*PasswordKey is Empty, wait for client send PasswordKey* <br />而不是之前的 <br />*prepare Email account < xxx@xxx.xx > OK*<br />
   因为服务器无法知道加密算子是什么，也就无法解密这个密码登录服务器，它需要等待客户端把这个加密算子发过来。
  * 客户端准备
   在客户端的高级设置里面，会有一个加密算子的选项，默认当然是空的，你需要填写一个之前使用加密工具加密明文密码使用用到的 * 密码算子* key，例如 "111"<br />
   [http://i.imgur.com/TloN6.png]<br />
   填写完毕之后，返回语盒连接状态界面（这个时候 *key 本身不会被保存，保存的是MD5(key) * ）就可点击连接即可，服务器会在第一时间收到这个这个密码算子的MD5值，然后解密密码，登录邮件服务器。此时服务器会输出<br />*used crpty Password key to decode.* <br />之后就是熟悉的<br />*prepare Email account < xxx@xxx.xx > OK*<br />
   这个解密过程，在整个服务器开始运行直到结束，无论客户端登录过几次，发送过多少次加密算子，都只会发生一次。

==为什么会相对安全？==

 * 先说一下为什么这个方法比较安全。
    
    首先MD5之前的加密算子只出现过两次，第一次是用工具的生成密文密码的时候，第二次，出现在手机端填写高级设置的时候。前者会存在内存里面，不会保存下来，后者会被MD5加密，存放在手机中。

    MD5是一个什么样的算法呢？就是不可逆算法，高深的数据道理不说，举个例子，就是有这么个一台机器，这边推进去的是驴和面粉，那边出来是驴肉火烧，你如果觉得驴肉太硬，想换个嫩一点的，然后把驴肉火烧从那边退回去，然后这边的驴和面粉有原封不动再退出来。嗯，想想都会违背常识，这就是不可逆，MD5处理过的东西是无法变回原样的。

    保存下来密码算子的MD5值，是无法还原成原来的明文算子的，比如无法知道这个算子是111。即便是手机遗失了，也无法获得算子的明文。也就无法知道是什么样的算子，MD5处理过后，加密了密码。

    如果仅仅服务器被攻破，获得邮箱密文，无法获得手机的密钥，因此无法破解。

 * 为什么又是相对的？

    还是密钥的问题，如果获得手机上面的语盒配置文件，获得了这个MD5值，再获得邮箱密码的密文，就能使用DES算法，解密出原来的密码，这就是不安全因素。

    还有一个不安全因素就是开放源代码，只要开放源代码，所有的加密解密过程都大白于天下，没有任何遮羞布。这是为什么谷歌吧很多产品都开源了，Gmail等带有账户信息产品却没有开源的原因之一。

    避免的方式只有一种，永远不要把手机和服务器一起“遗失”。 